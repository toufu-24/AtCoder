# generated by claude

import numpy as np

MOD = 998244353


def count_paths(N, M, K, additional_edges):
    # 隣接行列の初期化
    A = np.zeros((N, N), dtype=np.int64)

    # 基本の辺を追加
    for i in range(N):
        A[i][(i + 1) % N] = 1

    # 追加の辺を追加
    for u, v in additional_edges:
        A[u - 1][v - 1] += 1

    # ダブリングテーブルの初期化
    doubling = [A]

    # ダブリングテーブルの計算
    for i in range(60):  # 2^60 > 10^18 なので十分
        doubling.append(np.matmul(doubling[-1], doubling[-1]) % MOD)

    # K回の移動後の行列を計算
    result = np.eye(N, dtype=np.int64)
    for i in range(60):
        if (K >> i) & 1:
            result = np.matmul(result, doubling[i]) % MOD

    # 頂点1からの経路数を返す
    return sum(result[0]) % MOD


# 入力の読み込み
N, M, K = map(int, input().split())
additional_edges = []
for _ in range(M):
    x, y = map(int, input().split())
    additional_edges.append((x, y))

# 結果の計算と出力
result = count_paths(N, M, K, additional_edges)
print(result)
