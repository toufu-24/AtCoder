// A - Cleaning Up /
// 実行時間制限: 2 sec / メモリ制限: 1024 MB

// ストーリー
// ある会社では、現在働きやすい環境づくりを目指している。そこで新入社員が入社する 4 月から、社内の掃除を毎週行うことにした。 しかしながら、掃除当番は簡単に決められるものではない。 たとえば 1 人に負担をかけすぎてはならないことや、まだ仕事に慣れていない新入社員の負担は特に少なくしなければならないことなど、様々な制約がある。 また、掃除当番の決め方は「X さんの次は Y さんか Z さん」のように覚えやすいものでなければならない。 できるだけ制約通りになるように、掃除当番の決め方を最適化せよ。

// 問題文
// ある会社には
// N 人の社員がおり、それぞれ
// 0 から
// N−1 までの番号が付けられている。 あなたは、各社員
// i
// (0≤i≤N−1) について整数
// a
// i
// ​
//   と
// b
// i
// ​
//   を決め (
// a
// i
// ​
//  =b
// i
// ​
//   でも構わない)、以下の規則で各週の掃除当番を割り当てることにした。

// 最初の週は、社員
// 0 が掃除当番となる。
// それ以降の週については、前週の掃除当番を社員
// x とし、前週が終わった時点で社員
// x が掃除当番に
// t 回割り当てられたとして、今週の掃除当番は次のように決まる。
// t が奇数の場合: 社員
// a
// x
// ​

// t が偶数の場合: 社員
// b
// x
// ​

// 各
// i
// (0≤i≤N−1) について、今後
// L=500000 週間に社員
// i に掃除当番を割り当てる回数の目標値
// T
// i
// ​
//   が与えられる。 実際に社員
// i に割り当てられる掃除当番の回数を
// t
// i
// ​
//   とするとき、誤差
// ∣t
// 0
// ​
//  −T
// 0
// ​
//  ∣+∣t
// 1
// ​
//  −T
// 1
// ​
//  ∣+⋯+∣t
// N−1
// ​
//  −T
// N−1
// ​
//  ∣ をできるだけ小さくせよ。

// 得点
// 出力した掃除当番の決め方における誤差を
// E とするとき、
// 10
// 6
//  −E 点が得られる。 ここで、得点が負の値にならないことが保証される。

// 合計で 150 個のテストケースがあり、各テストケースの得点の合計が提出の得点となる。 一つ以上のケースで不正な出力や制限時間超過をした場合、提出全体の判定が  や  となる。 コンテスト時間中に得た最高得点で最終順位が決定され、コンテスト終了後のシステムテストは行われない。 同じ得点を複数の参加者が得た場合、提出時刻に関わらず同じ順位となる。

// 入力
// 入力は以下の形式で標準入力から与えられる。

// N
// L
// T
// 0
// ​

// T
// 1
// ​

// ⋯
// T
// N−1
// ​

// 全てのテストケースで、社員の数
// N は
// 100 で固定である。
// 全てのテストケースで、週数
// L は
// 500000 で固定である。
// 0≤T
// i
// ​
//  ≤10000 を満たす。
// T
// 0
// ​
//  +T
// 1
// ​
//  +⋯+T
// N−1
// ​
//  =L を満たす。
// 入力はすべて整数である。
// 出力
// 以下の形式で標準出力に出力せよ。

// a
// 0
// ​

// b
// 0
// ​

// a
// 1
// ​

// b
// 1
// ​

// ⋮
// a
// N−1
// ​

// b
// N−1
// ​

// ここで
// 0≤a
// i
// ​
//  ≤N−1 および
// 0≤b
// i
// ​
//  ≤N−1 を満たさない
// i
// (0≤i≤N−1) が存在する場合、 と判定される。

// 例を見る

// 入力生成方法
// L 以上
// U 以下の整数値を一様ランダムに生成する関数を
// rand(L,U) と表すとき、入力生成方法は次のようになる。

// 各
// 0≤i≤N−2 について、
// T
// i
// ​
//   の値を
// T
// i
// ​
//  =rand(0,10000) により生成する。
// 総和
// S=T
// 0
// ​
//  +⋯+T
// N−2
// ​
//   が
// 0≤L−S≤10000 を満たすならば
// T
// N−1
// ​
//  =L−S として入力を確定させる。そうでなければ、1. に戻って生成をやり直す。
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 100;                          // 社員数（固定）
const int L = 500000;                       // 週間数（固定）
const int SIM_STEPS = 50000;                // 評価用の部分シミュレーション週数
const double SCALE = SIM_STEPS / double(L); // 目標値スケール

// 各社員の目標掃除回数 T_arr
int T_arr[N];

// 貪欲法による初期解生成
// 各社員 i の辺（a[i] と b[i]）は，社員 i の重み T_arr[i] を用いて，
// 各流入先 j の deficit = 2*T_arr[j] - flow[j] が最大となるものを順次選ぶ．
void greedyInitialSolution(int a[N], int b[N]) {
    vector<double> desired(N, 0.0), flow(N, 0.0);
    for (int j = 0; j < N; j++) {
        desired[j] = 2.0 * T_arr[j]; // 目標流入量
        flow[j] = 0.0;               // 現在の流入量
    }

    // 各社員の辺割り当てを保存する（ans[i][0] が a[i]，ans[i][1] が b[i]）
    vector<array<int, 2>> ans(N);

    // 社員を T_arr の大きい順に処理する
    vector<int> order(N);
    for (int i = 0; i < N; i++)
        order[i] = i;
    sort(order.begin(), order.end(), [](int i, int j) {
        return T_arr[i] > T_arr[j];
    });

    // 各社員 i に対して2本の辺を貪欲に割り当てる
    for (int idx : order) {
        // 1本目の辺の候補選択
        int best_j = 0;
        double best_deficit = -1e18;
        for (int j = 0; j < N; j++) {
            double deficit = desired[j] - flow[j];
            if (deficit > best_deficit) {
                best_deficit = deficit;
                best_j = j;
            }
        }
        ans[idx][0] = best_j;
        flow[best_j] += T_arr[idx]; // 社員 idx の重みを加算

        // 2本目の辺の候補選択
        best_j = 0;
        best_deficit = -1e18;
        for (int j = 0; j < N; j++) {
            double deficit = desired[j] - flow[j];
            if (deficit > best_deficit) {
                best_deficit = deficit;
                best_j = j;
            }
        }
        ans[idx][1] = best_j;
        flow[best_j] += T_arr[idx];
    }

    // 最終的な割り当てを元の順序に戻して出力用配列にセット
    for (int i = 0; i < N; i++) {
        a[i] = ans[i][0];
        b[i] = ans[i][1];
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // 入力読み込み（N, L は固定値）
    int dummy;
    cin >> dummy; // N（必ず100）
    cin >> dummy; // L（必ず500000）
    for (int i = 0; i < N; i++) {
        cin >> T_arr[i];
    }

    int a[N], b[N];
    // 貪欲法による初期解生成
    greedyInitialSolution(a, b);
    
    for (int i = 0; i < N; i++) {
        cout << a[i] << " " << b[i] << endl;
    }

    return 0;
}
